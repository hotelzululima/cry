#!/usr/bin/env node

var net = require ('net');
var spawn = require ("child_process").spawn
var exec = require ("child_process").exec
var rl = require ('readline').createInterface (
		process.stdin, process.stdout, completer);
var UUID = 0;
var port = 9999
var host = undefined
var iam = process.env ["USER"] || undefined
var key = ""
var cry = __dirname + "/cry"
var forward = false; // not yet implemented
var reconnect = true;
var reconnect_every = 5;

rl.set_prompt = function (x) {
	var id = peer? peer.uuid: -1;
	if (x) rl.setPrompt ('\x1b[32m<'+x+':'+id+'> \x1b[0m', (x+id).length+4);
}
rl.set_prompt (iam)
rl.prompt ();
/* --- */
var p = spawn ("sh", [ "-c", "cry -l| grep ^p|head -n1|awk '{print $2}'" ])
p.stdout.on ('data', function (data) {
	iam = (""+data).trim ();
});
/* --- */

switch (process.argv.length) {
case 4:
	key = process.argv[2]
	port = process.argv[3]
	break;
case 5:
	key = process.argv[2]
	host = process.argv[3]
	port = process.argv[4]
	break;
default:
	console.log ("client: cryo [pubkey] [host] [port]")
	console.log ("server: cryo [pubkey] [port]")
	process.exit (1);
	break;
}

var cryo_import = function (name, key) {
	var p = spawn (cry, ['-i', name, '-']);
	var body = "";
	p.stdout.on ('data', function (data) {
		body += data;
	});
	p.stdout.on ('close', function (code) {
		print (body)
// XXX: todo use proper foo bar
	});
	p.stdin.write (key)
	p.stdin.on ("drain", function () {
		p.stdin.end ();
	});
}

var enc = (function (msg, cb) {
	var p = spawn (cry, ['-e', key]);
	var body = "";
	p.stdout.on ('data', function (data) {
		body += data;
	});
	p.stdout.on ('close', function (code) {
		cb (body);
	});
	p.stdin.write (msg)
	p.stdin.on ("drain", function () {
		p.stdin.end ();
	});
})

var dec = (function (msg, cb) {
	var body = "";
	var p = spawn (cry, ['-d']);
	p.stderr.on ('data', function (data) {
		data = (""+data).trim ()
		if (data.indexOf (' ') != -1)
			console.log ("ERROR "+data);
	});
	p.stdout.on ('data', function (data) {
		body += data;
	});
	p.stdout.on ('close', function (code) {
		cb (key, body);
	});
	p.stdin.write (msg.replace (/\r/g,''));
	p.stdin.on ("drain", function () {
		p.stdin.end ();
	});
})

function completer (line) {
	var completions = '/help /import /connect /disconnect /exit /key /list /peer'.split (' ');
	var hits = completions.filter(function(c) {
			if (c.indexOf(line) == 0) {
				return c;
			}});
	return [hits && hits.length ? hits : completions, line];
}

var peers = [];
var peer = undefined

function set_key (k) {
	if (peer)
		peer.key = k;
}

function set_peer (n) {
	var i = 0;
	for (var p in peers) {
		if (n == i++) {
			if ((peer = peers[p])) {
				key = peer.key;
				rl.set_prompt (key)
				return true;
			}
			return false;
		}
	}
	return false;
}

function list_peers () {
	var i = 0;
	for (var x in peers) {
		var p = peers[x];
		if (p) {
			var pn = "";
			if (p.pub_name)
				pn = "@("+p.pub_name+")";
			console.log (peer == p? '*': ' ',
				i, p.host+":"+p.port, p.key, pn);
		}
		i++;
	}
}

var offline = function () {
	status ("offline");
}
var sendmsg = offline;

function peersend (data, type) {
	if (type) {
		try {
			if (peer)
				peer.socket.write (type+"\n"+data)
		} catch (e) {
			print ("cannot write 0", e)
		}
		return;
	}
	type = "msg";
	enc (data, function (x) {
		try {
			if (peer)
				peer.socket.write (type+"\n"+x)
		} catch (e) {
			print ("cannot write 1")
		}
	});
}
function cryo_disconnect (host, port) {
	if (peer)
		peer.socket.destroy ();
}

var _status = undefined;

function status(x) {
	if (x) print (x)
	return x? _status = x: _status;
}

function print (x) {
	function atoi (x) {
		if (x<10) return "0"+x
		return x;
	}
	var util = require ('util')
	var d = new Date ();
	now = atoi (d.getHours ()) + ":" + atoi (d.getMinutes ())
	console.log ("\r\x1b[0K"+now+" "+x)
	rl.prompt (true);
}

function cryo_decode_msg (uuid, data) {
	var noff = data.indexOf ('\n');
	if (noff != -1) {
		header = data.substring (0, noff).split (' ')
		data = data.substring (noff+1)
	} else header = [];

	var input = (""+data).replace (/==/,'_=').split ('=');
	for (var i=0; i<input.length;i++) {
		var str = input[i].trim ().replace(/_/,'=') + "=";
		if (str == "=") continue;
		switch (header[0]) {
		case 'pub':
			console.log ("Received public key from "+header[1])
			console.log (data)
			console.log ("Type /import to accept it")
			peer.pub_name = header[1];
			peer.pub = data
			rl.prompt (true);
			break;
		case 'msg':
			dec (str, function (x, y) {
				print ("<"+key+":"+uuid+"> "+y.trim ())
			});
			break;
		default:
			print ("invalid packet");
			break;
		}
	}
}

function cryo_connect (host, port) {
	status ("connecting to "+host+":"+port);
	var c = net.connect (port, host, function () {
		var uuid = UUID++;
		var p = peers[uuid] = {
			'host':host,
			'port':port,
			'uuid' : uuid,
			'key' : key,
			'socket': c
		};
		if (!peer) peer = p;
		c.setNoDelay ();
		print ('connected');
		sendmsg = peersend;

		c.on ('data', function (data) {
			cryo_decode_msg (uuid, ""+data)
		});
		c.on ('end', function () {
			print ('peer disconnected');
			/* if (peer == c) {
				if (!set_peer (0))
					sendmsg = offline;
			} */
			sendmsg = offline;
			delete peers[uuid];
		});
	});
	c.on ('error', offline);
}

function cryo_pub (k) {
	var p = spawn (cry, ['-p', k]);
	var pubkey = "";
	p.stdout.on ('data', function (data) {
		pubkey += (""+data)
	});
	p.stdout.on ('close', function (data) {
		if (pubkey.length>0) {
			sendmsg (pubkey, "pub "+k);
		} else print ("Cannot find pubkey");
	});
}

function cryo_listen (port) {
	/* listen */
	var server = net.createServer (function (c) {
		var uuid = UUID++;
		c.on ('error', offline);
		c.setNoDelay ();
		print ("peer "+uuid+" connected");
		var p = peers[uuid] = {
			'host' : c.remoteAddress,
			'port' : c.remotePort,
			'uuid' : uuid,
			'key' : key,
			'socket': c
		}
		if (!peer) peer = p;
		rl.set_prompt (iam)
		sendmsg = peersend
		var input = "";
		c.on ('data', function (data) {
			cryo_decode_msg (uuid, ""+data)
		});
		c.on ('end', function () {
			print ('peer disconnected');
			peers[uuid] = undefined
		});
	});
	server.listen (port, function() {
		print ('listening on '+ port);
	});
}

/* main */
if (host) {
	cryo_connect (host, port);
	if (reconnect) {
		setInterval (function (x) {
			if (sendmsg == offline) {
				if (status () == "connecting")
					return;
				cryo_connect (host, port);
			}
		} , reconnect_every*1000);
	}
} else cryo_listen (port);

rl.on ('line', function (line) {
	var str = line.trim ();
	if (str[0] == '!') {
		str = str.substring (1);
		var p = spawn ("sh", ["-c", str])
		if (p) p.stdout.on ('data', function (data) {
			print (str+"\n"+(""+data).trim())
		});
	} else
	if (str[0] == '/') {
		var args = str.substring (1).split (/ /);
		switch (args[0]) {
		case 'connect':
			if (args[1]) host = args[1]
			if (args[2]) port = args[2]
			cryo_disconnect ();
			cryo_connect (host, port)
			break;
		case 'disconnect':
			cryo_disconnect ();
			break;
		case 'key':
			if (args[1]) {
				set_key (args[1]);
				if (key) rl.set_prompt (key = args[1]);
			} else print (key);
			break;
		case 'peer':
			if (args[1]) {
				if (!set_peer (args[1]))
					print ("invalid peer id")
			} else {
				if (peer) print (peer.uuid);
			}
			break;
		case 'help':
			console.log (
" /connect [host] [port]\n"+
" /disconnect       close connection to current peer\n"+
" /key [pubkey]     set key to encrypt\n"+
" /peer [id]        select a peer\n"+
" /pub [key]        send public key to peer\n"+
" /import           import key published by peer\n"+
" /list             list all peers\n"+
" /exit             quit the program"
			);
			break;
		case 'pub':
			if (args[1]) cryo_pub (args[1]);
			else console.log ("Missing argument");
			break;
		case 'list':
			list_peers ();
			break;
		case 'exit':
			console.log ("byebye");
			process.exit (0);
			break;
		case 'import':
			if (peer && peer.pub_name && peer.pub) {
				cryo_import (peer.pub_name, peer.pub);
				peer.pub_name = peer.pub = undefined;
			} else print ("Nothing to import");
			break;
		default:
			console.log ("Invalid command.");
			break;
		}
	} else {
		var str = line.trim ();
		if (str.length>0) sendmsg (str);
	}
	rl.prompt ();
}).on ('close', function () {
	console.log ("^D");
	process.exit (0);
});
